from ctypes import *
from _typeshed import Incomplete
from collections.abc import Generator

__all__ = ['AvailabilityKind', 'Config', 'CodeCompletionResults', 'CompilationDatabase', 'CompileCommands', 'CompileCommand', 'CursorKind', 'Cursor', 'Diagnostic', 'File', 'FixIt', 'Index', 'LinkageKind', 'SourceLocation', 'SourceRange', 'TLSKind', 'TokenKind', 'Token', 'TranslationUnitLoadError', 'TranslationUnit', 'TypeKind', 'Type']

class c_interop_string(c_char_p):
    def __init__(self, p: Incomplete | None = None) -> None: ...
    @property
    def value(self): ...
    @classmethod
    def from_param(cls, param): ...
    @staticmethod
    def to_python_string(x, *args): ...

class TranslationUnitLoadError(Exception): ...

class TranslationUnitSaveError(Exception):
    ERROR_UNKNOWN: int
    ERROR_TRANSLATION_ERRORS: int
    ERROR_INVALID_TU: int
    save_error: Incomplete
    def __init__(self, enumeration, message) -> None: ...

class CachedProperty:
    wrapped: Incomplete
    __doc__: Incomplete
    def __init__(self, wrapped) -> None: ...
    def __get__(self, instance, instance_type: Incomplete | None = None): ...

class _CXString(Structure):
    def __del__(self) -> None: ...
    @staticmethod
    def from_result(res, fn: Incomplete | None = None, args: Incomplete | None = None): ...

class SourceLocation(Structure):
    @staticmethod
    def from_position(tu, file, line, column): ...
    @staticmethod
    def from_offset(tu, file, offset): ...
    @property
    def file(self): ...
    @property
    def line(self): ...
    @property
    def column(self): ...
    @property
    def offset(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...

class SourceRange(Structure):
    @staticmethod
    def from_locations(start, end): ...
    @property
    def start(self): ...
    @property
    def end(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __contains__(self, other) -> bool: ...

class Diagnostic:
    Ignored: int
    Note: int
    Warning: int
    Error: int
    Fatal: int
    DisplaySourceLocation: int
    DisplayColumn: int
    DisplaySourceRanges: int
    DisplayOption: int
    DisplayCategoryId: int
    DisplayCategoryName: int
    ptr: Incomplete
    def __init__(self, ptr) -> None: ...
    def __del__(self) -> None: ...
    @property
    def severity(self): ...
    @property
    def location(self): ...
    @property
    def spelling(self): ...
    diag: Incomplete
    @property
    def ranges(self): ...
    @property
    def fixits(self): ...
    diag_set: Incomplete
    @property
    def children(self): ...
    @property
    def category_number(self): ...
    @property
    def category_name(self): ...
    @property
    def option(self): ...
    @property
    def disable_option(self): ...
    def format(self, options: Incomplete | None = None): ...
    def from_param(self): ...

class FixIt:
    range: Incomplete
    value: Incomplete
    def __init__(self, range, value) -> None: ...

class TokenGroup:
    def __init__(self, tu, memory, count) -> None: ...
    def __del__(self) -> None: ...
    @staticmethod
    def get_tokens(tu, extent) -> Generator[Incomplete, None, None]: ...

class TokenKind:
    value: Incomplete
    name: Incomplete
    def __init__(self, value, name) -> None: ...
    @staticmethod
    def from_value(value): ...
    @staticmethod
    def register(value, name) -> None: ...

class BaseEnumeration:
    value: Incomplete
    def __init__(self, value) -> None: ...
    def from_param(self): ...
    @property
    def name(self): ...
    @classmethod
    def from_id(cls, id): ...

class CursorKind(BaseEnumeration):
    @staticmethod
    def get_all_kinds(): ...
    def is_declaration(self): ...
    def is_reference(self): ...
    def is_expression(self): ...
    def is_statement(self): ...
    def is_attribute(self): ...
    def is_invalid(self): ...
    def is_translation_unit(self): ...
    def is_preprocessing(self): ...
    def is_unexposed(self): ...

class TemplateArgumentKind(BaseEnumeration): ...
class ExceptionSpecificationKind(BaseEnumeration): ...

class Cursor(Structure):
    @staticmethod
    def from_location(tu, location): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def is_definition(self): ...
    def is_const_method(self): ...
    def is_converting_constructor(self): ...
    def is_copy_constructor(self): ...
    def is_default_constructor(self): ...
    def is_move_constructor(self): ...
    def is_default_method(self): ...
    def is_mutable_field(self): ...
    def is_pure_virtual_method(self): ...
    def is_static_method(self): ...
    def is_virtual_method(self): ...
    def is_abstract_record(self): ...
    def is_scoped_enum(self): ...
    def get_definition(self): ...
    def get_usr(self): ...
    def get_included_file(self): ...
    @property
    def kind(self): ...
    @property
    def spelling(self): ...
    @property
    def displayname(self): ...
    @property
    def mangled_name(self): ...
    @property
    def location(self): ...
    @property
    def linkage(self): ...
    @property
    def tls_kind(self): ...
    @property
    def extent(self): ...
    @property
    def storage_class(self): ...
    @property
    def availability(self): ...
    @property
    def access_specifier(self): ...
    @property
    def type(self): ...
    @property
    def canonical(self): ...
    @property
    def result_type(self): ...
    @property
    def exception_specification_kind(self): ...
    @property
    def underlying_typedef_type(self): ...
    @property
    def enum_type(self): ...
    @property
    def enum_value(self): ...
    @property
    def objc_type_encoding(self): ...
    @property
    def hash(self): ...
    @property
    def semantic_parent(self): ...
    @property
    def lexical_parent(self): ...
    @property
    def translation_unit(self): ...
    @property
    def referenced(self): ...
    @property
    def brief_comment(self): ...
    @property
    def raw_comment(self): ...
    def get_arguments(self) -> Generator[Incomplete, None, None]: ...
    def get_num_template_arguments(self): ...
    def get_template_argument_kind(self, num): ...
    def get_template_argument_type(self, num): ...
    def get_template_argument_value(self, num): ...
    def get_template_argument_unsigned_value(self, num): ...
    def get_children(self): ...
    def walk_preorder(self) -> Generator[Incomplete, None, None]: ...
    def get_tokens(self): ...
    def get_field_offsetof(self): ...
    def is_anonymous(self): ...
    def is_bitfield(self): ...
    def get_bitfield_width(self): ...
    @staticmethod
    def from_result(res, fn, args): ...
    @staticmethod
    def from_cursor_result(res, fn, args): ...

class StorageClass:
    value: Incomplete
    def __init__(self, value) -> None: ...
    def from_param(self): ...
    @property
    def name(self): ...
    @staticmethod
    def from_id(id): ...

class AvailabilityKind(BaseEnumeration): ...

class AccessSpecifier(BaseEnumeration):
    def from_param(self): ...

class TypeKind(BaseEnumeration):
    @property
    def spelling(self): ...

class RefQualifierKind(BaseEnumeration):
    def from_param(self): ...

class LinkageKind(BaseEnumeration):
    def from_param(self): ...

class TLSKind(BaseEnumeration):
    def from_param(self): ...

class Type(Structure):
    @property
    def kind(self): ...
    parent: Incomplete
    length: Incomplete
    def argument_types(self): ...
    @property
    def element_type(self): ...
    @property
    def element_count(self): ...
    @property
    def translation_unit(self): ...
    @staticmethod
    def from_result(res, fn, args): ...
    def get_num_template_arguments(self): ...
    def get_template_argument_type(self, num): ...
    def get_canonical(self): ...
    def is_const_qualified(self): ...
    def is_volatile_qualified(self): ...
    def is_restrict_qualified(self): ...
    def is_function_variadic(self): ...
    def get_address_space(self): ...
    def get_typedef_name(self): ...
    def is_pod(self): ...
    def get_pointee(self): ...
    def get_declaration(self): ...
    def get_result(self): ...
    def get_array_element_type(self): ...
    def get_array_size(self): ...
    def get_class_type(self): ...
    def get_named_type(self): ...
    def get_align(self): ...
    def get_size(self): ...
    def get_offset(self, fieldname): ...
    def get_ref_qualifier(self): ...
    def get_fields(self): ...
    def get_exception_specification_kind(self): ...
    @property
    def spelling(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...

class ClangObject:
    obj: Incomplete
    def __init__(self, obj) -> None: ...
    def from_param(self): ...

class _CXUnsavedFile(Structure): ...

class CompletionChunk:
    class Kind:
        name: Incomplete
        def __init__(self, name) -> None: ...
    cs: Incomplete
    key: Incomplete
    def __init__(self, completionString, key) -> None: ...
    def spelling(self): ...
    def kind(self): ...
    def string(self): ...
    def isKindOptional(self): ...
    def isKindTypedText(self): ...
    def isKindPlaceHolder(self): ...
    def isKindInformative(self): ...
    def isKindResultType(self): ...

class CompletionString(ClangObject):
    class Availability:
        name: Incomplete
        def __init__(self, name) -> None: ...
    def __len__(self) -> int: ...
    def num_chunks(self): ...
    def __getitem__(self, key): ...
    @property
    def priority(self): ...
    @property
    def availability(self): ...
    @property
    def briefComment(self): ...

class CodeCompletionResult(Structure):
    @property
    def kind(self): ...
    @property
    def string(self): ...

class CCRStructure(Structure):
    def __len__(self) -> int: ...
    def __getitem__(self, key): ...

class CodeCompletionResults(ClangObject):
    ptr: Incomplete
    def __init__(self, ptr) -> None: ...
    def from_param(self): ...
    def __del__(self) -> None: ...
    @property
    def results(self): ...
    ccr: Incomplete
    @property
    def diagnostics(self): ...

class Index(ClangObject):
    @staticmethod
    def create(excludeDecls: bool = False): ...
    def __del__(self) -> None: ...
    def read(self, path): ...
    def parse(self, path, args: Incomplete | None = None, unsaved_files: Incomplete | None = None, options: int = 0): ...

class TranslationUnit(ClangObject):
    PARSE_NONE: int
    PARSE_DETAILED_PROCESSING_RECORD: int
    PARSE_INCOMPLETE: int
    PARSE_PRECOMPILED_PREAMBLE: int
    PARSE_CACHE_COMPLETION_RESULTS: int
    PARSE_SKIP_FUNCTION_BODIES: int
    PARSE_INCLUDE_BRIEF_COMMENTS_IN_CODE_COMPLETION: int
    @classmethod
    def from_source(cls, filename, args: Incomplete | None = None, unsaved_files: Incomplete | None = None, options: int = 0, index: Incomplete | None = None): ...
    @classmethod
    def from_ast_file(cls, filename, index: Incomplete | None = None): ...
    index: Incomplete
    def __init__(self, ptr, index) -> None: ...
    def __del__(self) -> None: ...
    @property
    def cursor(self): ...
    @property
    def spelling(self): ...
    def get_includes(self): ...
    def get_file(self, filename): ...
    def get_location(self, filename, position): ...
    def get_extent(self, filename, locations): ...
    tu: Incomplete
    @property
    def diagnostics(self): ...
    def reparse(self, unsaved_files: Incomplete | None = None, options: int = 0) -> None: ...
    def save(self, filename) -> None: ...
    def codeComplete(self, path, line, column, unsaved_files: Incomplete | None = None, include_macros: bool = False, include_code_patterns: bool = False, include_brief_comments: bool = False): ...
    def get_tokens(self, locations: Incomplete | None = None, extent: Incomplete | None = None): ...

class File(ClangObject):
    @staticmethod
    def from_name(translation_unit, file_name): ...
    @property
    def name(self): ...
    @property
    def time(self): ...
    @staticmethod
    def from_result(res, fn, args): ...

class FileInclusion:
    source: Incomplete
    include: Incomplete
    location: Incomplete
    depth: Incomplete
    def __init__(self, src, tgt, loc, depth) -> None: ...
    @property
    def is_input_file(self): ...

class CompilationDatabaseError(Exception):
    ERROR_UNKNOWN: int
    ERROR_CANNOTLOADDATABASE: int
    cdb_error: Incomplete
    def __init__(self, enumeration, message) -> None: ...

class CompileCommand:
    cmd: Incomplete
    ccmds: Incomplete
    def __init__(self, cmd, ccmds) -> None: ...
    @property
    def directory(self): ...
    @property
    def filename(self): ...
    @property
    def arguments(self) -> Generator[Incomplete, None, None]: ...

class CompileCommands:
    ccmds: Incomplete
    def __init__(self, ccmds) -> None: ...
    def __del__(self) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, i): ...
    @staticmethod
    def from_result(res, fn, args): ...

class CompilationDatabase(ClangObject):
    def __del__(self) -> None: ...
    @staticmethod
    def from_result(res, fn, args): ...
    @staticmethod
    def fromDirectory(buildDir): ...
    def getCompileCommands(self, filename): ...
    def getAllCompileCommands(self): ...

class Token(Structure):
    @property
    def spelling(self): ...
    @property
    def kind(self): ...
    @property
    def location(self): ...
    @property
    def extent(self): ...
    @property
    def cursor(self): ...

class LibclangError(Exception):
    m: Incomplete
    def __init__(self, message) -> None: ...

class Config:
    library_path: Incomplete
    library_file: Incomplete
    compatibility_check: bool
    loaded: bool
    @staticmethod
    def set_library_path(path) -> None: ...
    @staticmethod
    def set_library_file(filename) -> None: ...
    @staticmethod
    def set_compatibility_check(check_status) -> None: ...
    def lib(self): ...
    def get_filename(self): ...
    def get_cindex_library(self): ...
    def function_exists(self, name): ...
